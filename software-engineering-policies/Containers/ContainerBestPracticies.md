# Container Best Practices

## Dockerfile Best Practices

Docker provide a series of best practices for writing and developing Dockerfile’s. These are:

* Best practices for [writing a Dockerfile](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/).
* Best practices for [developing with Docker](https://docs.docker.com/develop/dev-best-practices/).
* Best practices for [secure development with Docker](https://docs.docker.com/develop/security-best-practices/).

The following items supersede these best practices:

* Where a container needs to use secrets and passwords, these should be injected into the container via environment variables defined in the Dockerfile and should be encrypted at a minimum.
* Dockerfile’s should be linted to detect issues and vulnerabilities
* Aim to use minimal dependencies, such as [distroless container base](https://github.com/GoogleContainerTools/distroless).
* Avoid defining unnecessary privileges and avoid running as root.
* Ensure there is a well-established process for updating dependencies.
* Where both suitable and possible, leverage [multi-stage builds](https://docs.docker.com/build/building/multi-stage).

## Container Deployment Best Practices

### Must Do

* Where applicable at deployment, secrets must be stored via Azure KeyVault, AWS Secrets Manager, etc.
* The containers resources, limits and requests for CPU and Memory consumption must be defined for deployment
* Containers deployments and deployment environment must be configured using infrastructure as code.
* Deployments must include a means to monitor the health of the container. For example, when using Kubernetes, configure readiness and liveliness probes.
* Environments above Dev must have HTTPS enforced and HTTP to HTTPS redirects enabled.
* Logs generated by containers must be consumed.
* Access to the underlying infrastructure running the container images must be blocked in all environments above Dev.
* Container images must be scanned by a vulnerability scanning tools.

### Should do

* Microservices and containers should communicate only with services and ports they need to.
* Access Policies and Network Security Groups should be applied.
* Container deployments should be isolated using Namespaces.
* Monitoring solution should be in place for deployed containers. For example, ELK (.Net), EFK (Java) stacks, Grafana, Prometheus etc.
* Automated deployments should be used on container image version increments within the container registry.

### Could do

* DAPR sidecar could be utilised for third party component management (queues, DB's etc).
* Native built in support within visual studio for Docker could be used for development and testing.
* Docker Compose could be utilised to stub other dependencies that the container uses.

## Best practice guides

* sysdig blog [post](<https://sysdig.com/blog/dockerfile-best-practices/>) on practices.
